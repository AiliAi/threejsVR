<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>

<body>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three/build/three.module.js"
				}
			}
		</script>

    <script type="module">

        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js';
        import { KTX2Loader } from 'https://unpkg.com/three/examples/jsm/loaders/KTX2Loader.js';
        import { MeshoptDecoder } from 'https://unpkg.com/three/examples/jsm/libs/meshopt_decoder.module.js';
        import { VRButton } from 'https://unpkg.com/three/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://unpkg.com/three/examples/jsm/webxr/XRControllerModelFactory.js';

        let controls, group;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        let raycaster;
        const raycastGroup = new THREE.Group();
        const mixers = [];
        const clock = new THREE.Clock();
        const intersected = [];
        const tempMatrix = new THREE.Matrix4();

        var scene = new THREE.Scene();

        /**************************** Add cubemap ******************************/
        const path = 'cubeMap/';
        const format = '.jpg';
        const urls = [
            path + 'px' + format, path + 'nx' + format,
            path + 'py' + format, path + 'ny' + format,
            path + 'pz' + format, path + 'nz' + format
        ];

        const reflectionCube = new THREE.CubeTextureLoader().load(urls);

        //refractionCube.mapping = THREE.CubeRefractionMapping;

        scene.background = reflectionCube;


        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        /**************************** Renderer and VR button ***************************/

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMapType = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));


        /**************************** Create Earth model ********************************/

        const geometry = new THREE.SphereGeometry(3, 36, 16);
        const geometryBigger = new THREE.SphereGeometry(3.02, 36, 16);

        const loader = new THREE.TextureLoader();
        const texture = new THREE.TextureLoader().load('EarthMaterials/earth_atmos_2048.jpeg');
        const bumpMap = new THREE.TextureLoader().load('EarthMaterials/earth_bump.jpeg');
        const specularMap = new THREE.TextureLoader().load('EarthMaterials/earth_specular_2048.jpeg');
        const normalMap = new THREE.TextureLoader().load('EarthMaterials/earth_normal_2048.jpeg');

        const material = new THREE.MeshPhongMaterial({
            map: texture,
            specularMap: specularMap,
            normalMap: normalMap,
            side: THREE.DoubleSide,
            bumpMap: bumpMap,
            bumpScale: 0.3,
            envMap: reflectionCube
        });

        var cube = new THREE.Mesh(geometry, material);
        cube.position.set(30, 10, -50);
        raycastGroup.add(cube);

        const textureCloud = new THREE.TextureLoader().load('EarthMaterials/earth_clouds_2048.png');
        const cloudsTransparent = new THREE.TextureLoader().load('EarthMaterials/earthcloudmaptrans.jpeg');

        const materialCloud = new THREE.MeshBasicMaterial({
            map: textureCloud,
            transparent: true,
            alphaMap: cloudsTransparent
        });

        var clouds = new THREE.Mesh(geometryBigger, materialCloud);
        clouds.position.set(30, 10, -50);
        scene.add(clouds);

        camera.position.z = 5;

        /****************************** Load Cat model **************************/

        const ktx2Loader = new KTX2Loader()
            .setTranscoderPath('js/libs/basis/')
            .detectSupport(renderer);

        const loaderObject = new GLTFLoader().setPath('models/');
        loaderObject.setKTX2Loader(ktx2Loader);
        loaderObject.setMeshoptDecoder(MeshoptDecoder);
        loaderObject.load('kissa.glb', function (gltf) {
            gltf.scene.traverse(function (node) {
                if (node.material) {
                    node.material.side = THREE.DoubleSide;
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });

            gltf.scene.position.y = -1;
            gltf.scene.position.x = -3;
            gltf.scene.position.z = -3;
            gltf.scene.scale.set(0.01, 0.01, 0.01);
            raycastGroup.add(gltf.scene);

        });

        /******************************** Load Bird animation *****************************/

        const loaderAnimation = new GLTFLoader().setPath('models/');
        loaderAnimation.load('Flamingo.glb', (gltf) => {

            const mesh = gltf.scene.children[0];

            const s = 0.015;
            mesh.scale.set(s, s, s);
            mesh.position.y = 2;
            mesh.position.x = 3;
            mesh.position.z = -1;
            mesh.rotation.y = - 1;

            mesh.castShadow = true;
            mesh.receiveShadow = true;

            raycastGroup.add(mesh);

            const mixer = new THREE.AnimationMixer(mesh);
            mixer.clipAction(gltf.animations[0]).setDuration(1).play();
            mixers.push(mixer);

        });


        /********************************** Create floor **********************************/

        const textureFloor = new THREE.TextureLoader().load('textures/fabric.jpg');
        const geometryFloor = new THREE.PlaneGeometry(30, 30);
        const materialFloor = new THREE.MeshPhongMaterial({
            map: textureFloor,
            side: THREE.DoubleSide
        });

        const floor = new THREE.Mesh(geometryFloor, materialFloor);
        floor.receiveShadow = true;
        floor.rotation.x = THREE.Math.degToRad(-90);
        floor.rotation.z = THREE.Math.degToRad(-90);
        floor.position.y = -7;
        floor.position.z = -3;
        floor.position.x = -2;


        /********************************* Lighting ****************************************/

        const light = new THREE.DirectionalLight(0xdddddd, 0.8);
        //light.target.position = 160;
        light.position.set(6, 6, 6);
        light.castShadow = true; // default false
        light.shadow.camera.top = 4;
        light.shadow.camera.bottom = - 4;
        light.shadow.camera.right = 4;
        light.shadow.camera.left = - 4;
        light.shadow.mapSize.set(4096, 4096);

        const lightAmb = new THREE.AmbientLight(0xffffff, 0.5);

        const lightHem = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.7);

        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;

        scene.add(floor, light, lightAmb, lightHem);

        scene.add(raycastGroup);

        /************************************ Controls **********************************/

        controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional

        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;

        controls.screenSpacePanning = false;

        controls.minDistance = 1;
        controls.maxDistance = 10;

        controls.maxPolarAngle = Math.PI / 2;

        camera.position.set(1, 3, 6);

        /************************************ Initialize XR **********************************/

        const cleanIntersected = () => {

            while (intersected.length) {

                const object = intersected.pop();
                object.material.emissive.r = 0;
            }
        }

        // controllers

        controller1 = renderer.xr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        controller1.addEventListener('connected', function (event) {

            this.add(buildController(event.data));

        });
        controller1.addEventListener('disconnected', function () {

            this.remove(this.children[0]);

        });
        scene.add(controller1);

        controller2 = renderer.xr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);
        controller2.addEventListener('connected', function (event) {

            this.add(buildController(event.data));

        });
        controller2.addEventListener('disconnected', function () {

            this.remove(this.children[0]);

        });
        scene.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);


        //Add own controller model

        const myControlModel = new GLTFLoader().setPath('models/');
        myControlModel.load('fork.glb', (gltf) => {

            //const loaderObject2 = new GLTFLoader().setPath('models/gundy/');
            //loaderObject2.load('scene.gltf', function (gltf) {

            gltf.scene.scale.set(0.07, 0.07, 0.07);
            let mymodel = gltf.scene;
            //mymodel.rotation.y = THREE.Math.degToRad(180);
            mymodel.position.set(0, -0.01, 0);
            controller2.add(mymodel);
            console.log(mymodel);
        });

        const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, - 1)]);

        const line = new THREE.Line(lineGeometry);
        line.name = 'line';
        line.scale.z = 5;

        controller1.add(line.clone());
        controller2.add(line.clone());

        raycaster = new THREE.Raycaster();

        const buildController = (data) => {

            let geometry, material;

            switch (data.targetRayMode) {

                case 'tracked-pointer':

                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

                    material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

                    return new THREE.Line(geometry, material);

                case 'gaze':

                    geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
                    material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
                    return new THREE.Mesh(geometry, material);
            }
        }

        function onSelectStart(event) {

            const controller = event.target;

            const intersections = getIntersections(controller);

            if (intersections.length > 0) {
                const intersection = intersections[0];

                const object = intersection.object;
                object.material.emissive.b = 1;
                controller.attach(object);

                controller.userData.selected = object;
            }
        }

        function onSelectEnd(event) {

            const controller = event.target;

            if (controller.userData.selected !== undefined) {
                const object = controller.userData.selected;
                object.material.emissive.b = 0;
                raycastGroup.attach(object);

                controller.userData.selected = undefined;
            }
        }

        const intersectObjects = (controller) => {

            // Do not highlight when already selected

            if (controller.userData.selected !== undefined) return;

            const line = controller.getObjectByName('line');
            const intersections = getIntersections(controller);

            if (intersections.length > 0) {
                const intersection = intersections[0];

                const object = intersection.object;
                object.material.emissive.r = 1;
                intersected.push(object);

                line.scale.z = intersection.distance;
            } else {
                line.scale.z = 5;
            }
        }

        const getIntersections = (controller) => {

            tempMatrix.identity().extractRotation(controller.matrixWorld);

            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

            return raycaster.intersectObjects(raycastGroup.children, true);

            const cleanIntersected = () => {

                while (intersected.length) {
                    const object = intersected.pop();
                    object.material.emissive.r = 0;
                }
            }
        }

        /************************************ Animate **********************************/

        renderer.setAnimationLoop(function () {
            cube.rotation.y += 0.001;

            clouds.rotation.y += 0.002;

            controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
            cleanIntersected();

            const delta = clock.getDelta();
            for (let i = 0; i < mixers.length; i++) {

                mixers[i].update(delta);

            }

            intersectObjects(controller1);
            intersectObjects(controller2);

            renderer.render(scene, camera);
        });

        /************************************ Window resize **********************************/

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);

    </script>

</body>

</html>